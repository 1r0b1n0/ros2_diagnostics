#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2008, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the Willow Garage nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

## A basic node to monitor diagnostics for expected status

import roslib; roslib.load_manifest('runtime_monitor')

import sys, time
import rospy
from diagnostic_msgs.msg import DiagnosticMessage, DiagnosticStatus, DiagnosticValue, DiagnosticString

NAME = 'runtime_test'

# must initialize a node before we call get_time()
rospy.init_node(NAME, anonymous=True)

latest_messages = {}
test_name = 'uninitialized'
status_name = 'Runtime Test'
package = 'uninitialized'
last_runtime = rospy.get_time()
startup_delay = 5.0
start_time = rospy.get_time()

# Records status as dictionary by labels for strings, values
# Also stores last time of message, allows stale checks.
def status_to_map(status):
    str_map = {}
    for s in status.strings:
        str_map[s.label] = s.value;
    for val in status.values:
        str_map[val.label] = val.value;
    str_map["name"]= status.name
    str_map["message"] = status.message

    # Store last time message was recorded
    str_map["last_time"] = rospy.get_time()
    return str_map
    
def analyze(test_impl, params):
    # The test takes the latest_messages dictionary, the private parameters
    # and the status name (the name of the DiagnosticStatus message
    # it publishes)
    return test_impl.test(latest_messages, params, status_name)

def callback(message, args):
    for s in message.status:
        latest_messages[s.name] = status_to_map(s)
    execute_test(args)

def execute_test(args):
    global last_runtime
    global publisher

    if rospy.get_time() < start_time + startup_delay:
        rospy.logdebug("Waiting to for startup delay")
        return
    
    # Don't execute at greater than max frequency
    time_step = rospy.get_time() - last_runtime
    if 1.0 / time_step > options.max_freq:
        return
    else:
        last_runtime = rospy.get_time()
    
    test_impl, params = args

    msg = DiagnosticMessage()
    msg.status = [analyze(test_impl, params)]
    publisher.publish(msg)

def runtime_test(package, test_name):
    # retrieve the test implementation
    roslib.load_manifest(package)
    __import__("%s.%s"%(package, test_name))
    try:
        pypkg = sys.modules[package]
    except KeyError:
        print >> sys.stderr, "ERROR: cannot locate test package %s"%package
        rospy.logerr("cannot locate test package %s"%package)
        sys.exit(1)
    test_impl = getattr(pypkg, test_name)    

    # must be inited before reading parameters
    rospy.init_node(NAME, anonymous=True)

    # get it's parameters
    params = rospy.get_param("~")

    rospy.Subscriber("/diagnostics", DiagnosticMessage, callback, (test_impl, params))

    # Publish in diagnostics the test results
    global publisher
    publisher = rospy.Publisher('/diagnostics', DiagnosticMessage)
    
    # Always executes at greater than the min frequency
    while not rospy.is_shutdown():
        if rospy.get_time() - last_runtime > 1/options.min_freq:
            execute_test((test_impl, params))
        time.sleep(0.5/options.min_freq)
        
if __name__ == '__main__': 
    from optparse import OptionParser
    parser = OptionParser(usage="usage: %prog [options]", prog='runtime_test')
    parser.add_option("--test", metavar="TEST_NAME",
                      dest="test_name", default='', 
                      type="string", help="test name")
    parser.add_option("--name", metavar="STATUS_NAME",
                      dest="status_name", default='Runtime Test', 
                      type="string", help="Name of status message")
    parser.add_option("--package", metavar="ROS_PACKAGE",
                      dest="package", default='runtime_monitor', 
                      type="string", help="package test is in")
    parser.add_option("--min_freq", metavar="min_frequency",
                      dest="min_freq", default='0.5', 
                      type="float", help="Minimum Execution Frequency(Hz)")
    parser.add_option("--max_freq", metavar="max_frequency",
                      dest="max_freq", default='1.0', 
                      type="float", help="Maximum Execution Frequency(Hz)")
    parser.add_option("--startup_delay", metavar="startup_delay",
                      dest="startup_delay", default='5.0', 
                      type="float", help="Time to wait before Polling(Seconds)")
    

    options, args = parser.parse_args()

    
    # expected or default
    package = options.package 
    startup_delay = options.startup_delay
    
    status_name = options.status_name

    if options.test_name:
        test_name = options.test_name 
    else:
        parser.error("you must give me a test to run")

    try:
        runtime_test(package, options.test_name)
    except KeyboardInterrupt, e:
        pass
    print "exiting"
